# Exercise 6

## Presentation

## Continuations

Given the arithmetic expression `1 + 2 - x`, assume a _call-by-value_,
_left-to-right_ evaluation order, we can identify 7 continuations during the
evaluation of the expression (at the top level).  They are the continuation

1. `[]` awaiting the value of `1 + 2 - x`
2. `1 + 2 [] x` awaiting the value of `-`
3. `[] - x` awaiting the value of `1 + 2`
4. `1 [] 2 - x` awaiting the value of `+`
5. `[] + 2 - x` awaiting the value of `1`
6. `1 + [] - x` awaiting the value of `2`
7. `3 - []` awaiting the value of `x`

## Tail Calls

Tail calls are explained as follows using the high-level concept of
continuation.  For a low-level explanation (that I attempted in the exercise
session), see the paper [Lambda: The Ultimate
GOTO](http://repository.readscheme.org/ftp/papers/ai-lab-pubs/AIM-443.pdf).

### Tail Position

An expression `e1` is in _tail position_ with respect to an enclosing
expression `e2` if the continuation `c1` of `e1` is _effectively_ the same as
the continutation `c2` of `e2`.  So the value of `e1` when returned to `c1`
is then immediately returned to `c2`.

For example, the expression `n` is _not_ in tail position in the `then`-branch
but in tail position in the `else`-branch of expression `if (n < 0) then (- n)
else n`

### Tail Call

A function call occurs in tail position is a _tail call_.  For example, in the
following Haskell code, the recursive call of `fac` does _not_ occur in tail
position, hence _not_ a tail call; whereas the recursive call of `fact` _does_
occur in tail position, hence a tail call.

```haskell
fac n =
  if n == 0
    then 1
    else n * fac (n - 1)

fact f n =
  if n == 0
    then f
    else fact (f * n) (n - 1)
```

### Tail-Call Optimization

The value of a tail call can be returned directly to the continuation of its
enclosing expression, bypassing its own continuation.  So the intermediate
continuation can be optimized away hence does not even have to be created and
saved at all.  This process of eliminating the continuaton of a tail call,
hence replacing it with the continuation of its eclosing expression is called
_tail-call optimization_.  It saves space.

### Tail Recursion

If the recursive call in a recursive-function definition is a tail call, it is
called _tail recursive_.  This form of recursion is called _tail recursion_.
With tail-call optimization, tail recursion can be as efficient as iteration in
space.  Consider the evaluation of `fac 3` and `fact 1 3`.  The definition of
`fac` is not tail recursive.  Tail-call optimization can not be applied to save
space for intermediate continuations.

```
[fac 3]
3 * [fac 2]
3 * 2 * [fac 1]
3 * 2 * 1 * [fac 0]
3 * 2 * [1 * 1]
3 * [2 * 1]
[3 * 2]
[6]
```

The definition of `fact` is tail recursive.  Tail-call optimization eliminates
the intermediate continuations.  The calculation is done in constant space.

```
[fact 1 3]
[fact 3 2]
[fact 6 1]
[fact 6 0]
[6]
```

