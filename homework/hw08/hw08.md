# Homework 8

## Monad Laws

To qualify as a monad, a type constructor plus an implementation of `unit` and
`bind` of the correct type is _not_ enough.  In addition, they must also
respect the following three algebraic laws:

- Left identity: `bind(unit(x), f)` = `f(x)`

- Right identity: `bind(m, unit)` = `m`

- Associativity: `bind(bind(m, f), g)` = `bind(m, (x => bind(f(x), g)))`

Note two things:

- In this exercise, Scala is our object language, English plus mathematics is
our meta-language.  We already know that we can use a meta-language (Scala) to
_implement_ object languages like AE, WAE, FAE, etc.  Here we use
a meta-language (English plus mathematics) to _discuss_ (the properties of) an
object language (Scala).  You have been exposed to this discussion since the
very beginning of the course: lectures, comments, exercises all _discuss_
Scala.  In summary, we use Scala to _implement_ languages like AE, WAE, FAE
etc., and we use English plus mathematics to _discuss_ our implementations in
Scala.  Properly layered according to the meaning of the prefix
[meta-](http://www.ldoceonline.com/dictionary/meta-), AE, WAE, FAE, etc. are
our object languages, Scala is our meta-language, and English plus mathematics
is our meta-meta-language.  Now comes the _real_ point: the equal sign '=' in
the above three laws are _not_ the equal sign `=` in Scala, they belong to our
meta-meta-language, that is, English plus mathematics.  So this exercise does
_not_ require Scala programming or testing, but _does_ require Scala program
understanding and mathematical equational reasoning.  For example, we can
establish the equality between the Scala expressions `((x : Int)(y : Int) =>
x + y)(1)(2)` and `3` via the following equational reasoning according to the
(substitution-based) evaluation rules of Scala:

      `((x : Int)(y : Int) => x + y)(1)(2)`
    = `((y : Int) => 1 + y)(2)`
    = `1 + 2`
    = `3`

- The annonymous function appearing in the Associativity law may not be quite
valid Scala per se due to the lack of parameter type.  But assume that all
variables appearing in the above three laws are well typed in the surrounding
context so that all expressions involved in the equations are valid in Scala.
For example, for the first equation to make sense, if `x` has type `A`, then
`f` should have type `A => M[B]`.  Actually, when you do equational reasoning,
you should make sure that all expressions through your equational reasoning,
including those in intermediate steps, are well typed in Scala.

Your tasks are:

1. Rephrase the three laws in terms the `do`-notation defined below:

    `do(x, m, e)` = `bind(m, x => e)`

   _Hint:_ Look closer, doesn't it ring a bell?

2. Show that the `IdentityMonad`, the `ReaderMonad`, the `StateMonad` and the
`ContinuatioinMonad` (_optional_, _recommended_) all satisfy these laws.  You
can choose to work with the definitions in either lecture note
[18-monads.scala](../../lecturenotes/18-monads.scala) or
[monad-library.scala](../../lecturenotes/19-monads-library.scala).

3. Why do you think monads should abey these monad laws?

## Monads in Action

### Programming Task 1

### Programming Task 2

## Syntactic Sugar and Desugaring

### Programming Task 1

Syntactic sugar stands for syntactic constructs added to a language to make the
taste of the language a bit sweeter: these constructs make the program easier
to read or write.  On the other hand, these constructs are not essential to the
language because they can always be transformed to those essential ones.  We
call this transformation desugaring.

So far, we have encountered several syntactic constructs that we claim to be
syntactic sugar.  For example, after introducing
[FAE](../../lecturenotes/05-fae.scala), we said that the `With` (hereafter
called `Let`) construct can be provided as syntactic sugar.  We even give
a definition like the following:

```scala
def let(vname : Symbol, vdef : Exp, body : Exp) = App(Fun(vname, body), vdef)
```

However, this definition does _not_ give the user of our object language (i.e.,
the implemented language) FAE the `Let` construct as syntactic sugar.  Because
`let` here is defined as a meta-function in our meta-language (i.e., the
implementation language) Scala!  We ourselves, as language designer and
implementer, have access to `let`: whenever we want to write `App(Fun('x,
Var('x)), Num(1))`, we can write the shorter and clearer `let('x, Num(1),
Var('x))` instead.  Scala will interpret it and replace it with `App(Fun('x,
Var('x)), Num(1))` whereever it appears.  So it benefits us.  But since it is
a meta-function, the user of the object language does _not_ have any access to
it.  Whenever the user wants to write an expression in the FAE language, the
only constructs (s)he can use are those provided by our declaration: `Var`,
`Fun`, `App`, `Num` and `If0`.  In other words, we have _not_ provided the user
the syntactic sugar yet.  But the beneficial `let` can be easily promoted to the
object language level.  The way to achieve this is to first extend our construct
declaration for FAE with a new construct `Let`:

```scala
abstract class Exp

// primitive constructs
case class Var(name : Symbol) extends Exp
case class Fun(pname : Symbol, body : Exp) extends Exp
case class App(fexp : Exp, aexp : Exp) extends Exp
case class Num(num : Int) extends Exp
case class Add(lexp : Exp, rexp : Exp) extends Exp
case class If0(cond : Exp, texp : Exp, fexp : Exp) extends Exp

abstract class Val

type Env = Map[Symbol, Val]

case class NumV(num : Int) extends Val
case class CloV(pname : Symbol, body : Exp, env : Env) extends Val

// the good old `eval`
def eval(exp : Exp, env : Env) : Val = ...

// syntactic sugar
case class Let(vname : Symbol, vdef : Exp, body : Exp) extends Exp
```

With this new `Let` construct, now the user can also write `Let('x, Num(1),
Var('x))` to mean `App(Fun('x, Var('x)), Num(1))`.  Although we have added this
new construct, we do not want to modify our interpreter to handle this new
case.  Instead, we turn expressions built using this new construct into
expressions expressed using more primitive constructs, so `Let('x, Num(1),
Var('x))` will be turned into `App(Fun('x, Var('x)), Num(1))`.  But note that
this addition gives the user the freedom to use `Let` wherever it makes sense.
In other words, `Let` can now appear everywhere an `Exp` is allowed!  For
example, it may appear as the `body` of a `Fun`.  So given an expression by the
user, we need to find every occurrence of `Let` in this expression and desugar
it to its corresponding more primitive expression.  Your task is to define such
a desugaring procedure:

```scala
def desugar(exp : Exp) : Exp = ...
```

The result of `desugar(exp)` will be an expression built using only primitive
constructs.  How should you evaluate expressions now?  _Hint:_ Directly call
the good old `eval` will not work, because an expression now may contain `Let`.
Give a new evaluation function called `eval1`:

```scala
def eval1(exp : Exp, env : Env) : Val = ...
```

Make sure your implementation pass the following tests and more.

```
val iniEnv : Env = Map()

def evalTest(exp : Exp) : Val = eval1(exp, iniEnv)

assert(evalTest(Let('x, Num(1), Var('x))) == NumV(1))
assert(evalTest(App(Fun('y, Let('x, Num(1), Add(Var('x), Var('y)))), Num(2))) == NumV(3))
```

### Programming Task 2 (Optional, Recommended)

Implement the `do` notation introduced in Problem 1 as syntactic sugar.

