# Homework 6

## Continuation-Passing Style

What is continuation-passing style?  What is the characteristics of programs in
continuation-passing style?

## Manual CPS-Transformation

CPS-transform the following functions in Scala by hand.  You can leave `==`,
`*`, `-` and `+` as is without transforming them.

```scala
// the factorial function
def fact(n : Int) : Int = if (n == 0) 1 else n * fact(n - 1)

// the Fibonacci function
def fibo(n : Int) : Int =
  if (n == 0) 0
  else if (n == 1) 1
  else fibo(n - 2) + fibo(n - 1)

// the fold function
def fold(f : (Int, Int) => Int, z : Int, xs : List[Int]) : Int = xs match {
  case Nil => z
  case x :: ys => f(x, fold(f, z, ys))
}
```

Note that this is a Scala source-to-source transformation.  Continuations are
represented as Scala functions.  For example, the identity function on integers

```scala
def id(x : Int) : Int = x
```

after manual CPS-transformation becomes

```scala
def id(x : Int, c : Int => Int) : Int = ((c : Int => Int) => c(x))(c)
```

_Hint:_ Study carefully how `cps` defined in the [lecture
notes](../../lecturenotes/14-cpstransformation2.scala) transforms expressions
in the FAE language, and map back `CPSCont` to Scala functions, `CPSApp` to
Scala function applications.

For `fact` and `fibo`, do stack-overflow exceptions still occur when executing
the transformed program on large inputs?

## Automatic CPS-Transformation

In the [2nd lecture](../../lecturenotes/14-cpstransformation2.scala) on
CPS-transformation, we define two new syntactic categories, namely `CPSVal` and
`CPSExp`, for CPS-transformed terms.  In particular, the functioin `cps` takes
an `Exp` as input and returns a `CPSCont` as output.  CPS-transformation can be
done as a desugaring procedure which transforms an `Exp` to an `Exp`.  Start
with the following declarations, reimplement this desugaring-style
CPS-transformation.

```scala
abstract class Exp

case class Var(name : Symbol) extends Exp
case class Fun(pname : Symbol, body : Exp) extends Exp
case class App(fexp : Exp, aexp : Exp) extends Exp
case class Num(num : Int) extends Exp
case class Add(lhs : Exp, rhs : Exp) extends Exp
case class If0(cond : Exp, texp : Exp, fexp : Exp) extends Exp
case class Wth(vname : Symbol, vdef : Exp, body : Exp) extends Exp

abstract class Val

type Env = Map[Symbol, Val]

case class NumV(num : Int) extends Val
case class CloV(pname : Symbol, body : Exp, env : Env) extends Val  // closure

def cps(exp : Exp) : Exp = ...
```

Recall that the `Wth`-construct can also be defined as follows:

```scala
def Wth(vname : Symbol, vdef : Exp, body : Exp) : Exp =
  App(Fun(vname, body), vdef)
```

Hence `Wth('x, Num(1), Add(Var('x), Num(1)))` and `App(Fun('x, Add(Var('x),
Num(1))), Num(1))` are equivalent.  Now use your `cps` to transform both.
Compare the results of the transformation.  What can you conlude from the
comparison?

